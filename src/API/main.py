from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from langchain.llms import OpenAI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import StreamingResponse
from roadmapper.roadmap import Roadmap
from roadmapper.timelinemode import TimelineMode
from io import BytesIO
from PIL import Image
import tempfile
from datetime import datetime, timedelta
import random

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Initialize the LangChain LLM (replace with your actual API key or setup)
llm = OpenAI(api_key="")

class PlaceRequest(BaseModel):
    place: str

@app.post("/recommend/")
async def recommend_places(request: PlaceRequest):
    try:
        place = request.place
        
        # Define the prompt template
        prompt_template = f"Find a couple of top places to visit in {place}. For each place generate the name and a very short description of the place."

        # Get response from the LLM
        response = llm(prompt_template)

        # Return the response as JSON
        return {"recommendations": response}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/why-visit/")
async def why_visit_place(request: PlaceRequest):
    try:
        place = request.place
        
        # Define the prompt template for visit reasons
        prompt_template = f"Explain very shortly why someone should visit {place}."

        # Get response from the LLM
        response = llm(prompt_template)

        # Return the response as JSON
        return {"reason": response}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/create-trip-plan/")
async def create_trip_plan(request: PlaceRequest):
    place = request.place
    
    try:
        # Generate the roadmap tasks from LangChain
        tasks_response = llm(f"Generate four specific tasks (2 words each) for a trip to {place}.")

        # Debug output
        print("Tasks Response:", tasks_response)

        # Parse the response to get tasks
        tasks = parse_tasks(tasks_response)
        print("Parsed Tasks:", tasks)
        
        # Create the roadmap
        roadmap = Roadmap(1200, 400, colour_theme="BLUEMOUNTAIN")
        roadmap.set_title(f"Trip Plan to {place}")

        # Calculate number of items to display 2-month intervals
        number_of_items = 3  # Adjust based on the total duration you want to show

        # Set timeline to 2-month intervals
        roadmap.set_timeline(
            mode=TimelineMode.MONTHLY,
            start="2024-01-01",
            number_of_items=number_of_items,
            show_generic_dates=False
        )

        roadmap.set_footer("Generated by Roadmapper")

        # Add a group for the entire trip duration
        roadmap_group = roadmap.add_group(f"Trip Duration: {place}")

        # Dates for tasks
        start_date = datetime(2024, 1, 1)
        two_weeks = timedelta(weeks=2)

        # Add tasks to the roadmap group with overlapping durations
        for task_name in tasks:
            # Randomly decide a start date within the first month
            task_start_date = start_date + timedelta(days=random.randint(0, 30))
            task_end_date = task_start_date + two_weeks - timedelta(days=1)
            # Convert dates to string in the format expected by roadmapper
            task_start_date_str = task_start_date.strftime('%Y-%m-%d')
            task_end_date_str = task_end_date.strftime('%Y-%m-%d')
            print(f"Adding Task: {task_name} from {task_start_date_str} to {task_end_date_str}")
            roadmap_group.add_task(task_name, task_start_date_str, task_end_date_str)
        
        # Draw the roadmap
        roadmap.draw()

        # Save to a temporary file
        with tempfile.NamedTemporaryFile(delete=False, suffix=".png") as temp_file:
            temp_filename = temp_file.name
            roadmap.save(temp_filename)  # Save the roadmap to the temporary file
            
            # Read the temporary file into a BytesIO stream
            with open(temp_filename, "rb") as f:
                image_stream = BytesIO(f.read())

        # Return the image as a StreamingResponse
        image_stream.seek(0)
        return StreamingResponse(image_stream, media_type="image/png")
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

def parse_tasks(tasks_response: str):
    tasks = []
    lines = tasks_response.split('\n')
    for line in lines:
        if line.strip():  # Non-empty line
            tasks.append(line.strip())
    return tasks

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
